# -*- coding: utf-8 -*-
"""iris-classification-multi-class-ova-and-ovo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V-gDodoDr__Xmr0y_PMYRi5J7TQWzHlB

**** # This  is multiclass Iris classification using one versus all and one versus one each part will be explained bellow *******

#  In this part we are loading the data set from sklearn library with extracting our target values
"""

#Data Pre-processing Step  
# importing libraries  
import numpy as np 
import pandas as pd 
from sklearn.datasets import load_iris
#import  our svm classifier
from sklearn.svm import SVC
from sklearn.multiclass import OneVsRestClassifier
from sklearn.multiclass import OneVsOneClassifier
#import library for splitting data 
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, roc_curve, auc, precision_score, PrecisionRecallDisplay
from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import classification_report
import time 
#loading the data set 
data = load_iris()
print("Our Target values are : ", list(data.target_names))

"""# here we need to split our data into Training Data and Test Data """

#import our validation metrics
#set our x, y (input and output)
X, Y = data.data, data.target
#split our data into training and validation  (70% training, 30% validation)
x_train,x_test, y_train, y_test=train_test_split(X, Y,test_size=0.30)

"""# This part present 
# - the prediction of feature vector in each kernel with multiclass one versus one using the function OneVsOneClassifier from sklearn.multiclass library 
# -  The accuracy 
# - The Recall AUC 
# - The CC Training time 
# - Confusion matrix 
"""

for kernel in ["linear", "rbf", "poly","sigmoid"]:
    print('-------------------------------------------------------------------------')
    print('[ ---- Start Model with %s kernel  ------  ]'%kernel)
    print('-------------------------------------------------------------------------')
    model =  OneVsRestClassifier(SVC( kernel = kernel))
#train the model :
    model.fit(x_train, y_train)
    prediction = model.predict(x_test)
    print("----------------------- Model SVM with %s --------------------------------------- "%kernel)
    #/******** accuracy  part **************************/
    accuracy = accuracy_score(y_test, prediction)*100
    print("--------------------  Accuracy score for %s kernel ---------------------"%kernel)
    print("Accuracy : ", accuracy)
    print ('---------------------   CONFUSION MATRIX for %s kernel-------------------------------'%kernel)
    results = confusion_matrix(y_test, prediction)
    print(results)
    #report 
    print ("---------------------  %s kernel  classification report  -------------------------- "%kernel)
    print(classification_report(y_test,prediction))
    debut =time.time()
    model.fit(x_train,y_train)
    Temps=time.time()-debut
    
    print("----------------  %s kernel time training calcul --------------------- "%kernel)
    print(Temps)
    #Recall test 
    print ("/*********** %s kernel  Recall calcul *****/"%kernel)
    fp, tp , thresholds =roc_curve(y_test, prediction, pos_label=1)
    print(fp, tp)
    AUC=auc(fp,tp)*100
    print('Recall: %.3f' % AUC)
    #roc curve 
    print ("/****** VISUALIZATION OF ROC CURVE for %s kernel  ********/"%kernel)
    plt.plot(fp, tp, color='blue',label = 'AUC = %0.2f' % AUC)
    plt.title('Receiver Operating Characteristic')
    #plt.plot(fpr, tpr, 'b', label = 'AUC = %0.2f' % AUC)
    plt.legend(loc = 'lower right')
    plt.plot([0, 1], [0, 1],'r--')
    plt.xlim([0, 1])
    plt.ylim([0, 1])
    plt.ylabel('True Positive Rate')
    plt.xlabel('False Positive Rate')
    plt.show()
    #print with heatmap
    class_names=[0,1] # name  of classes
    fig, ax = plt.subplots()
    tick_marks = np.arange(len(class_names))
    plt.xticks(tick_marks, class_names)
    plt.yticks(tick_marks, class_names)
    # create heatmap
    # CM1=pd.DataFrame(CM)
    # print(CM1)
    sns.heatmap(pd.DataFrame(results), annot=True, cmap="YlGnBu" ,fmt='g')
    ax.xaxis.set_label_position("top")
    #plt.tight_layout()
    plt.title('Confusion matrix', y=1.1)
    plt.ylabel('Actual label')
    plt.xlabel('Predicted label')
    plt.show()
   
print('-------------------------------------------------------------------------')

"""# This part present 
# - the prediction of feature vector in each kernel with multiclass one versus all using the function OnevsRestClassifier from sklearn.multiclass library 
# -  The accuracy 
# - The Recall AUC 
# - The CC Training time 
# - Confusion matrix 
"""

from colorama import Fore, Back, Style
print(Fore.MAGENTA + '----------------one vers one classifier in multiclass for each kernel --------------------------')
for kernel in ["linear", "rbf", "poly","sigmoid"]:
    print('-------------------------------------------------------------------------')
    print('[ ---- Start Model with %s kernel  ------  ]'%kernel)
    print('-------------------------------------------------------------------------')
    model =  OneVsOneClassifier(SVC( kernel = kernel))
	#train the model :
    model.fit(x_train, y_train)
    prediction = model.predict(x_test)
    print("----------------------- Model SVM with %s --------------------------------------- "%kernel)
    #/******** accuracy  part **************************/
    accuracy = accuracy_score(y_test, prediction)*100
    print("--------------------  Accuracy score for %s kernel ---------------------"%kernel)
    print("Accuracy : ", accuracy)
    print ('---------------------   CONFUSION MATRIX for %s kernel-------------------------------'%kernel)
    results = confusion_matrix(y_test, prediction)
    print(results)
    #report 
    print ("---------------------  %s kernel  classification report  -------------------------- "%kernel)
    print(classification_report(y_test,prediction))
    debut =time.time()
    model.fit(x_train,y_train)
    Temps=time.time()-debut
    
    print("----------------  %s kernel time training calcul --------------------- "%kernel)
    print(Temps)
    #Recall test 
    print ("/*********** %s kernel  Recall calcul *****/"%kernel)
    fp, tp , thresholds =roc_curve(y_test, prediction, pos_label=1)
    print(fp, tp)
    AUC=auc(fp,tp)*100
    print('Recall: %.3f' % AUC)
    #roc curve 
    print ("/****** VISUALIZATION OF ROC CURVE for %s kernel  ********/"%kernel)
    plt.plot(fp, tp, color='blue',label = 'AUC = %0.2f' % AUC)
    plt.title('Receiver Operating Characteristic')
    #plt.plot(fpr, tpr, 'b', label = 'AUC = %0.2f' % AUC)
    plt.legend(loc = 'lower right')
    plt.plot([0, 1], [0, 1],'r--')
    plt.xlim([0, 1])
    plt.ylim([0, 1])
    plt.ylabel('True Positive Rate')
    plt.xlabel('False Positive Rate')
    plt.show()
    #print with heatmap
    class_names=[0,1] # name  of classes
    fig, ax = plt.subplots()
    tick_marks = np.arange(len(class_names))
    plt.xticks(tick_marks, class_names)
    plt.yticks(tick_marks, class_names)
    # create heatmap
    # CM1=pd.DataFrame(CM)
    # print(CM1)
    sns.heatmap(pd.DataFrame(results), annot=True, cmap="YlGnBu" ,fmt='g')
    ax.xaxis.set_label_position("top")
    #plt.tight_layout()
    plt.title('Confusion matrix', y=1.1)
    plt.ylabel('Actual label')
    plt.xlabel('Predicted label')
    plt.show()
    print('-------------------------------------------------------------------------')